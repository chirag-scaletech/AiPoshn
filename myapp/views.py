import asyncio
import base64
import json
import os
import random
import re
import tempfile
from http import client

from django.http import JsonResponse
from django.utils.decorators import method_decorator
from django.views import View
from django.views.decorators.csrf import csrf_exempt
from dotenv import load_dotenv
from drf_yasg import openapi
from drf_yasg.utils import swagger_auto_schema
from openai import OpenAI
from rapidfuzz import fuzz
from rest_framework import status
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView

from .models import Teacher
from .serializers import TeacherSerializer

load_dotenv()  # Loads from .env
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

class TeacherCreateAPIView(APIView):
    @swagger_auto_schema(
        manual_parameters=[
            openapi.Parameter(
                name="lang",
                in_=openapi.IN_QUERY,
                type=openapi.TYPE_STRING,
                description="Language code: 'en' (English) or 'gu' (Gujarati)",
                required=False,
                default='en'
            )
        ]
    )
    def post(self, request):
        lang = request.query_params.get('lang')
        if not lang:
            return Response({'error': "Missing 'lang' parameter"}, status=status.HTTP_400_BAD_REQUEST)

        if lang not in ['en', 'gu']:
            return Response({'error': "Invalid language. Use 'en' or 'gu'"}, status=status.HTTP_400_BAD_REQUEST)

        names_en = ["Vaishaliben Patel", "Parulben Shah", "Manishaben Desai"]
        names_gu = ["рк╡рлИрк╢рк╛рк▓рлАркмрлЗрки рккркЯрлЗрк▓", "рккрк╛рк░рлВрк▓ркмрлЗрки рк╢рк╛рк╣", "ркоркирлАрк╖рк╛ркмрлЗрки ркжрлЗрк╕рк╛ркИ"]

        schools_en = ["Government Primary School, Sector 15"]
        schools_gu = ["рк╕рк░ркХрк╛рк░рлА рккрлНрк░рк╛ркеркорк┐ркХ рк╢рк╛рк│рк╛, рк╕рлЗркХрлНркЯрк░ рлзрлл"]

        locations_en = ["Gandhinagar, Gujarat"]
        locations_gu = ["ркЧрк╛ркВркзрлАркиркЧрк░, ркЧрлБркЬрк░рк╛ркд"]

        index = random.randint(0, len(names_en) - 1)

        teacher = Teacher.objects.create(
            username_en=names_en[index],
            username_gu=names_gu[index],
            school_en=schools_en[0],
            school_gu=schools_gu[0],
            location_en=locations_en[0],
            location_gu=locations_gu[0],
        )

        return Response(TeacherSerializer(teacher).data, status=status.HTTP_201_CREATED)


class TeacherListAPIView(APIView):
    def get(self, request):
        lang = request.query_params.get('lang', 'en')
        if lang not in ['en', 'gu']:
            return Response({'error': 'Invalid language'}, status=status.HTTP_400_BAD_REQUEST)

        teachers = Teacher.objects.all()
        data = []
        for teacher in teachers:
            data.append({
                "id": teacher.id,
                "username": teacher.username_en if lang == 'en' else teacher.username_gu,
                "school": teacher.school_en if lang == 'en' else teacher.school_gu,
                "location": teacher.location_en if lang == 'en' else teacher.location_gu
            })
        return Response(data, status=status.HTTP_200_OK)

class TeacherDetailAPIView(APIView):
    @swagger_auto_schema(
        manual_parameters=[
            openapi.Parameter(
                name="lang",
                in_=openapi.IN_QUERY,
                type=openapi.TYPE_STRING,
                description="Language code: 'en' (English) or 'gu' (Gujarati)",
                required=False,
                default='en'
            )
        ]
    )
    def get(self, request, pk):

        lang = request.query_params.get('lang', 'en')
        if lang not in ['en', 'gu']:
            return Response({'error': 'Invalid language'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            teacher = Teacher.objects.get(pk=pk)
        except Teacher.DoesNotExist:
            return Response({'error': 'Teacher not found'}, status=status.HTTP_404_NOT_FOUND)

        data = {
            "id": teacher.id,
            "username": teacher.username_en if lang == 'en' else teacher.username_gu,
            "school": teacher.school_en if lang == 'en' else teacher.school_gu,
            "location": teacher.location_en if lang == 'en' else teacher.location_gu
        }
        return Response(data, status=status.HTTP_200_OK)

class SurveyAPIView(APIView):
    permission_classes = [AllowAny]  # Optional: allows public access
    def get(self, request, lang=None):
        lang = lang or request.query_params.get('lang', 'en')
        if lang not in ['en', 'gu']:
            return JsonResponse({'error': 'Invalid language'}, status=400)

        if lang == 'gu':
            survey = {
                "surveyTitle": "ркоркзрлНркпрк╛рки ркнрлЛркЬрки ркиркирк░рлАркХрлНрк╖ркг ркорк╛ркЯрлЗ рккрлНрк░рк╢рлНркирк╛рк╡рк▓рлА",
                "description": "ркнрлЛркЬрки рк╕рлЗрк╡рк╛ рккрк░ ркирк┐рк░рлАркХрлНрк╖ркг ркорк╛ркЯрлЗ ркирлАркЪрлЗ ркЖрккрлЗрк▓рк╛ рккрлНрк░рк╢рлНркирлЛркирк╛ ркЬрк╡рк╛ркм ркЖрккрлЛ.",
                "questions": [
                    {
                        "id": "q1",
                        "text": "ЁЯН╜я╕П ркнрлЛркЬрки ркЕркЧрк╛ркЙ ркиркХрлНркХрлА ркХрк░рлЗрк▓ ркорлЗркирлНркпрлБ ркорлБркЬркм ркЖрккрк╡рк╛ркорк╛ркВ ркЖрк╡рлНркпрлБркВ рк╣ркдрлБркВ ркХрлЗ ркирк╣рлАркВ?",
                        "options": ["тЬЕ рк╣рк╛, ркорлЗркирлНркпрлБ ркорлБркЬркм рк╕ркВрккрлВрк░рлНркг", "тЩ╗я╕П ркерлЛркбрлА рклрлЗрк░рклрк╛рк░ рк╕рк╛ркерлЗ", "тЪая╕П ркорлЛркЯрк╛ рклрлЗрк░рклрк╛рк░ рк╕рк╛ркерлЗ",
                                    "тЭМ ркорлЗркирлНркпрлБ ркорлБркЬркм ркирк╣рлЛркдрлБркВ"]
                    },
                    {
                        "id": "q2",
                        "text": "ЁЯСитАНЁЯН│ ркЖрккрлЗрк▓рк╛ ркнрлЛркЬркиркирлА ркЧрлБркгрк╡ркдрлНркдрк╛ рк╕ркВркдрлЛрк╖ркХрк╛рк░ркХ рк╣ркдрлА ркХрлЗ ркирк╣рлАркВ?",
                        "options": ["ЁЯМЯ ркЦрлВркм рк╕рк╛рк░рлА", "ЁЯСН рк╕рк╛рк░рлА", "ЁЯШР рк╕рк░рлЗрк░рк╛рк╢", "ЁЯСО ркиркмрк│рлА"]
                    },
                    {
                        "id": "q3",
                        "text": "ЁЯНЫ рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУ ркорк╛ркЯрлЗ ркнрлЛркЬркиркирлБркВ рккрлНрк░ркорк╛ркг рккрлВрк░ркдрлБркВ рк╣ркдрлБркВ ркХрлЗ ркирк╣рлАркВ?",
                        "options": ["тЬЕ рк╣рк╛, ркмркзрк╛ркирк╛ ркорк╛ркЯрлЗ рккрлВрк░ркдрлБркВ рк╣ркдрлБркВ", "тЪая╕П ркЕркВрк╢ркдркГ рккрлВрк░ркдрлБркВ рк╣ркдрлБркВ", "тЭЧ ркерлЛркбрк╛ркХ ркорк╛ркЯрлЗ ркУркЫрлБркВ рккркбрлНркпрлБркВ",
                                    "тЭМ ркмрк┐рк▓ркХрлБрк▓ рккрлВрк░ркдрлБркВ рки рк╣ркдрлБркВ"]
                    },
                    {
                        "id": "q4",
                        "text": "ЁЯУК ркХрлЗркЯрк▓рк╛ркВ ркЯркХрк╛ рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУркП ркорлЛркЯрк╛ркнрк╛ркЧркирлБркВ ркнрлЛркЬрки рк▓рлАркзрлБркВ рк╣ркдрлБркВ?",
                        "options": ["ЁЯТп 100%", "ЁЯУЙ 75тАУ80%", "ЁЯУЙ 50тАУ60%", "ЁЯУЙ 20тАУ30%"]
                    },
                    {
                        "id": "q5",
                        "text": "ЁЯЩЕтАНтЩВя╕П ркЖркЬрлЗ ркЖрккрлЗрк▓рлБркВ ркнрлЛркЬрки ркХрлЛркИ рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркП ркЦрк╛рк╡рк╛ркирлБркВ ркиркХрк╛рк░рлНркпрлБркВ рк╣ркдрлБркВ?",
                        "options": ["ЁЯШК ркХрлЛркИркП рки ркиркХрк╛рк░рлА", "ЁЯШР рлзтАУрли рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУ", "тШ╣я╕П рлйтАУрлл рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУ",
                                    "ЁЯШа рлл ркХрк░ркдрк╛ркВ рк╡ркзрлБ рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУ"]
                    },
                    {
                        "id": "q6",
                        "text": "ЁЯз╝ ркнрлЛркЬрки рк╡рк╣рлЗркВркЪркгрлА ркжрк░ркорк┐ркпрк╛рки ркХрлЛркИ рк╕рклрк╛ркИ ркЕркерк╡рк╛ рк╕рлНрк╡ркЪрлНркЫркдрк╛ркирлА рк╕ркорк╕рлНркпрк╛ ркЬрлЛрк╡рк╛ ркорк│рлА рк╣ркдрлА?",
                        "options": ["тЬЕ ркирк╛", "тЪая╕П рк╣рк│рк╡рлА рк╕ркорк╕рлНркпрк╛", "ЁЯЪл ркЧркВркнрлАрк░ рк╕ркорк╕рлНркпрк╛", "ЁЯЩИ ркзрлНркпрк╛ркиркорк╛ркВ ркиркерлА"]
                    },
                    {
                        "id": "q7",
                        "text": "ЁЯШК ркнрлЛркЬрки рккркЫрлА рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУ рк╕ркВркдрлЛрк╖ ркЕркирлЗ ркЖркиркВркжрк┐ркд рк▓рк╛ркЧрлНркпрк╛?",
                        "options": ["ЁЯШД ркмркзрк╛ рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУ", "ЁЯЩВ ркорлЛркЯрк╛ ркнрк╛ркЧркирк╛ рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУ", "ЁЯШР ркерлЛркбрк╛ркХ рк╡рк┐ркжрлНркпрк╛рк░рлНркерлАркУ", "ЁЯШЮ ркХрлЛркИ ркирк╣рк┐"]
                    }
                ]

            }
        else:
            survey = {
                "surveyTitle": "Questionnaire for Mid-Day Meal Observation",
                "description": "Please answer the following questions for meal service monitoring.",
                "questions": [
                    {
                        "id": "q1",
                        "text": "ЁЯН╜я╕П Was the meal served as per the pre-decided menu?",
                        "options": ["тЬЕ Yes, exactly as per menu", "тЩ╗я╕П Minor changes", "тЪая╕П Major changes",
                                    "тЭМ Not at all as per menu"]
                    },
                    {
                        "id": "q2",
                        "text": "ЁЯСитАНЁЯН│ Was the quality of food served satisfactory?",
                        "options": ["ЁЯМЯ Very good", "ЁЯСН Good", "ЁЯШР Average", "ЁЯСО Poor"]
                    },
                    {
                        "id": "q3",
                        "text": "ЁЯНЫ Was the quantity of food sufficient for all students?",
                        "options": ["тЬЕ Yes, sufficient for all", "тЪая╕П Partially sufficient", "тЭЧ Insufficient for some",
                                    "тЭМ Not sufficient at all"]
                    },
                    {
                        "id": "q4",
                        "text": "ЁЯУК What percentage of students consumed the major portion of their meal?",
                        "options": ["ЁЯТп 100%", "ЁЯУЙ 75тАУ80%", "ЁЯУЙ 50тАУ60%", "ЁЯУЙ 20тАУ30%"]
                    },
                    {
                        "id": "q5",
                        "text": "ЁЯЩЕтАНтЩВя╕П Did any student refuse to eat the food served today?",
                        "options": ["ЁЯШК No student refused", "ЁЯШР 1тАУ2 students", "тШ╣я╕П 3тАУ5 students",
                                    "ЁЯШа More than 5 students"]
                    },
                    {
                        "id": "q6",
                        "text": "ЁЯз╝ Were there any visible hygiene or cleanliness issues during food distribution?",
                        "options": ["тЬЕ No issues", "тЪая╕П Minor concern", "ЁЯЪл Major concern", "ЁЯЩИ Not Observed"]
                    },
                    {
                        "id": "q7",
                        "text": "ЁЯШК Did students appear happy and satisfied after the meal?",
                        "options": ["ЁЯШД All students", "ЁЯЩВ Most students", "ЁЯШР Few students", "ЁЯШЮ None"]
                    }
                ]

            }

        return JsonResponse(survey, safe=False)


class UploadImage(APIView):
    permission_classes = [AllowAny]  # Optional: allows public

    parser_classes = (MultiPartParser, FormParser)

    @swagger_auto_schema(
        manual_parameters=[
            openapi.Parameter(
                name="lang",
                in_=openapi.IN_FORM,
                type=openapi.TYPE_STRING,
                description="Language code ('en' or 'gu')",
                required=True,
            ),
            openapi.Parameter(
                name="menu",
                in_=openapi.IN_FORM,
                type=openapi.TYPE_STRING,
                description="JSON list of menu items as string, e.g., [\"poha\", \"sev\"]",
                required=True,
            ),
            openapi.Parameter(
                name="image",
                in_=openapi.IN_FORM,
                type=openapi.TYPE_FILE,
                description="Image file of the food plate",
                required=True,
            ),
        ]
    )

    @csrf_exempt
    def post(self, request):
        if request.method != "POST":
            return JsonResponse({"error": "Only POST method allowed"}, status=405)

            # Get and validate language
        lang = request.POST.get("lang")
        if not lang:
            return JsonResponse({"error": "Missing 'lang' parameter"}, status=400)
        if lang not in ["en", "gu"]:
            return JsonResponse({"error": "Invalid language. Use 'en' or 'gu'"}, status=400)

        # Get image
        image_file = request.FILES.get("image")
        if not image_file:
            return JsonResponse({"error": "Missing 'image' parameter"}, status=400)

        # Parse menu (expecting a JSON string list in FormData)
        raw_menu = request.POST.get("menu", "[]")
        print("raw_menu", raw_menu)
        try:
            menu_items = json.loads(raw_menu)
            if not isinstance(menu_items, list) or not all(isinstance(item, str) for item in menu_items):
                raise ValueError
        except Exception:
            return JsonResponse({"error": "Invalid 'menu' format. Must be a JSON list of strings."}, status=400)

        # Normalize menu list
        menu_list = [item.strip().lower() for item in menu_items if item.strip()]

        if not menu_list:
            return JsonResponse({"error": "Menu list is empty or invalid"}, status=400)

        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as temp_img:
            for chunk in image_file.chunks():
                temp_img.write(chunk)
            image_path = temp_img.name

        try:
            with open(image_path, "rb") as img_file:
                image_bytes = img_file.read()
                image_base64 = base64.b64encode(image_bytes).decode("utf-8")

            # Prompts for language
            if lang == "gu":
                # prompt_food = "ркЖ ркЫркмрлАркорк╛ркВ ркдркорлЗ ркХркпрк╛ ркЦрлЛрк░рк╛ркХ рк╡рк╕рлНркдрлБркУ ркЬрлЛркИ рк╢ркХрлЛ ркЫрлЛ? рклркХрлНркд ркпрк╛ркжрлА ркЖрккрлЛ. ркдркорк╛рко ркорк╛рк╣рк┐ркдрлА ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ."
                prompt_food = "ркЖ ркЪрк┐ркдрлНрк░ркорк╛ркВ ркжрк░рлНрк╢рк╛рк╡рк╛ркпрлЗрк▓ ркЦрлЛрк░рк╛ркХркирлА ркУрк│ркЦ ркХрк░рлЛ. ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХркирлЛ рк╕рлНрккрк╖рлНркЯ ркЙрк▓рлНрк▓рлЗркЦ ркХрк░рлЛ. рклркХрлНркд ркпрк╛ркжрлА ркЖрккрлЛ. ркдркорк╛рко ркорк╛рк╣рк┐ркдрлА ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ."

                # prompt_food = "ркЖ ркЪрк┐ркдрлНрк░ркорк╛ркВ ркжрк░рлНрк╢рк╛рк╡рк╛ркпрлЗрк▓ ркЦрлЛрк░рк╛ркХркирлА ркУрк│ркЦ ркХрк░рлЛ. ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХркирлЛ рк╕рлНрккрк╖рлНркЯ ркЙрк▓рлНрк▓рлЗркЦ ркХрк░рлЛ, ркЬрлЛ рк╢ркХрлНркп рк╣рлЛркп ркдрлЛ ркЖ рк╡рк╛ркиркЧрлАркУркирлБркВ рк╕рк╛ркорк╛ркирлНркп рк╡рк░рлНркЧрлАркХрк░ркг рккркг ркХрк░рлЛ (ркЬрлЗрко ркХрлЗ ркорлБркЦрлНркп ркЦрлЛрк░рк╛ркХ, ркорлАркарк╛ркИ, рк╕рк╛ркИркб ркбрк┐рк╢ рк╡ркЧрлЗрк░рлЗ). ркорк╛ркдрлНрк░ ркЦрлЛрк░рк╛ркХркирк╛ ркирк╛ркорлЛ ркЕркирлЗ рк╡рк░рлНркгрки ркЖрккрлЛ тАУ рк╡рлНркпркХрлНркдрк┐, рккрлНрк▓рлЗркЯ ркЕркерк╡рк╛ рккрлГрк╖рлНркаркнрлВркорк┐ рк╡рк┐рк╢рлЗ ркХркВркИ рккркг рки рк▓ркЦрлЛ. ркдркорк╛рко ркорк╛рк╣рк┐ркдрлА ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ. "

                # prompt_food = "ркЖ ркЫркмрлАркорк╛ркВ ркжрлГрк╢рлНркпркорк╛рки ркЦрлЛрк░рк╛ркХ рк╡рк╕рлНркдрлБркУркирлА рк╕рк░рк│, рк╡рк┐рк╢рк┐рк╖рлНркЯ ркпрк╛ркжрлА ркЖрккрлЛ. ркжрк░рлЗркХ рк╡рк╕рлНркдрлБ ркЕрк▓ркЧ рккркВркХрлНркдрк┐ркорк╛ркВ рк▓ркЦрлЛ. рк╕ркорк╛рки рк╡рк╕рлНркдрлБркУркирлЗ ркПркХрк╕рк╛ркерлЗ ркЬрлВрке рки ркХрк░рлЛ. рклркХрлНркд ркЦрлЛрк░рк╛ркХркирк╛ркВ ркирк╛рко рк▓ркЦрлЛ тАФ рк╡рк┐рк╢рлЗрк╖ркгрлЛ ркХрлЗ рк╡рк░рлНркгркирлЛ ркирк╣рлАркВ. ркдркорк╛рко ркорк╛рк╣рк┐ркдрлА ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ."

                # prompt_nutrition = "ркЖ ркЫркмрлАркорк╛ркВ ркдркоркирлЗ ркХркпрк╛ ркЦрк╛ркжрлНркп рккркжрк╛рк░рлНркерлЛ ркжрлЗркЦрк╛ркп ркЫрлЗ? ркЙрккрк░рк╛ркВркд, ркжрк░рлЗркХ рк╡рк╕рлНркдрлБ ркорк╛ркЯрлЗ, ркХрлЗрк▓рк░рлА, рккрлНрк░рлЛркЯрлАрки, ркЪрк░ркмрлА ркЕркирлЗ ркХрк╛рк░рлНркмрлЛрк╣рк╛ркЗркбрлНрк░рлЗркЯрлНрк╕ ркЬрлЗрк╡рлА ркЕркВркжрк╛ркЬрк┐ркд рккрлЛрк╖ркХ ркорк╛рк╣рк┐ркдрлА ркЖрккрлЛ. "
                prompt_nutrition = (
                    "ркдркорк╛рко ркорк╛рк╣рк┐ркдрлА ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ"
                    "ркЖ ркЫркмрлАркорк╛ркВ ркдркоркирлЗ ркХркпрк╛ ркЦрк╛ркжрлНркп рккркжрк╛рк░рлНркерлЛ ркжрлЗркЦрк╛ркп ркЫрлЗ? "
                    "ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХ рк╡рк╕рлНркдрлБ ркорк╛ркЯрлЗ рккрк╣рлЗрк▓рлЗ ркдрлЗркирлБркВ ркирк╛рко рк▓ркЦрлЛ ркЕркирлЗ рккркЫрлА ркдрлЗркирлА ркЕркВркжрк╛ркЬрк┐ркд рккрлЛрк╖ркХ ркорк╛рк╣рк┐ркдрлА ркЖрккрлЛ тАФ "
                    "ркЬрлЗрко ркХрлЗ ркХрлЗрк▓рк░рлА, рккрлНрк░рлЛркЯрлАрки, ркЪрк░ркмрлА ркЕркирлЗ ркХрк╛рк░рлНркмрлЛрк╣рк╛ркЗркбрлНрк░рлЗркЯрлНрк╕. "
                    "ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХ рк╡рк╕рлНркдрлБркирлЗ ркЕрк▓ркЧ рк░рлАркдрлЗ ркЬркгрк╛рк╡рлЛ. ркдркорк╛рко ркорк╛рк╣рк┐ркдрлА ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ."
                )


            else:
                prompt_food = "What food items do you see in this image? Just list them. Please provide all information in the English language only."
                prompt_nutrition = "What food items do you see in this image? Also, for each item, provide its approximate nutritional information such as calories, protein, fat, and carbs. Please provide all information in the English language only."

            system_prompt = "You are a food image detection expert. Identify all food items visible in the image."

            # GPT call: Detected food items
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt_food},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{image_base64}",
                                    "detail": "low"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=150,
                temperature=1
            )

            # GPT call: Nutrition
            responseNutrition = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": prompt_nutrition},
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{image_base64}",
                                    "detail": "low"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=300
            )

            gpt_reply = response.choices[0].message.content.strip().lower()
            print("gpt_reply",gpt_reply)

            detected_items = [
                item.strip("- ").strip()
                for item in gpt_reply.split("\n")
                if item.strip()
            ]

            def normalize(text):
                return re.sub(r"\s+", "", text.lower())

            found_items = []
            for item in menu_list:
                for detected in detected_items:
                    score = fuzz.partial_ratio(item, detected)
                    if score >= 85:
                        found_items.append(item)
                        break

            missing_items = [item for item in menu_list if item not in found_items]

            gpt_reply_Nutrition = responseNutrition.choices[0].message.content.strip().lower()
            print(gpt_reply_Nutrition)

            max_retries = 3
            nutritions = {}
            for attempt in range(max_retries):
                nutritions = self.parse_nutrition_info(gpt_reply_Nutrition)
                if nutritions:
                    break  # тЬЕ Success
            return JsonResponse({
                "items_food": detected_items,
                "input_menu": menu_list,
                "found_items": found_items,
                "missing_items": missing_items,
                "nutritions": nutritions
            })

        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)

    def parse_nutrition_info(self, gpt_reply_Nutrition: str) -> dict:
        nutritions = {}
        current_item = None

        for line in gpt_reply_Nutrition.split("\n"):
            line = line.strip()
            if not line:
                continue

            # Match item title: e.g., "1. **poha (flattened rice)**" or "**poha**"
            item_match = re.match(r"^(?:\d+\.\s*)?\*{2}(.+?)\*{2}", line)
            if item_match:
                current_item = item_match.group(1).strip()
                nutritions[current_item] = {}
                continue

            # Match nutrition info lines under the item
            if current_item:
                nutrition_match = re.match(
                    r"[-*]?\s*\*{0,2}([\w\u0A80-\u0AFF\s():]+)\*{0,2}\s*[:я╝Ъ]\s*(.+)", line)
                if nutrition_match:
                    key = nutrition_match.group(1).strip().lower()
                    value = nutrition_match.group(2).strip()
                    nutritions[current_item][key] = value

        return nutritions


@method_decorator(csrf_exempt, name="dispatch")
class FoodImageAPIView(View):
    permission_classes = [AllowAny]  # Optional: allows public

    parser_classes = (MultiPartParser, FormParser)

    @swagger_auto_schema(
        manual_parameters=[
            openapi.Parameter(
                name="lang",
                in_=openapi.IN_FORM,
                type=openapi.TYPE_STRING,
                description="Language code ('en' or 'gu')",
                required=True,
            ),
            openapi.Parameter(
                name="menu",
                in_=openapi.IN_FORM,
                type=openapi.TYPE_STRING,
                description="JSON list of menu items as string, e.g., [\"poha\", \"sev\"]",
                required=True,
            ),
            openapi.Parameter(
                name="image",
                in_=openapi.IN_FORM,
                type=openapi.TYPE_FILE,
                description="Image file of the food plate",
                required=True,
            ),
        ]
    )

    async def post(self, request):
        # Validate method
        if request.method != "POST":
            return JsonResponse({"error": "Only POST method allowed"}, status=405)

        # Validate parameters
        lang = request.POST.get("lang")
        if lang not in ("en", "gu"):
            return JsonResponse({"error": "Invalid or missing 'lang' parameter"}, status=400)

        image_file = request.FILES.get("image")
        if not image_file:
            return JsonResponse({"error": "Missing 'image' parameter"}, status=400)

        raw_menu = request.POST.get("menu", "[]")
        try:
            menu_items = json.loads(raw_menu)
            if not isinstance(menu_items, list) or not all(isinstance(i, str) for i in menu_items):
                raise ValueError
        except Exception:
            return JsonResponse(
                {"error": "Invalid 'menu'. Must be JSON list of strings."},
                status=400
            )

        menu_list = [item.strip().lower() for item in menu_items if item.strip()]
        if not menu_list:
            return JsonResponse({"error": "Parsed menu list is empty"}, status=400)

        # Save uploaded image to temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp:
            for chunk in image_file.chunks():
                tmp.write(chunk)
            image_path = tmp.name

        try:
            with open(image_path, "rb") as f:
                # image_base64 = base64.b64encode(f.read()).decode()
                # Convert image to base64 (you can keep this sync)
                image_base64 = self._convert_image_to_base64(image_file)

            # Select prompts
            prompts = self._get_language_prompts(lang)
            system_prompt = "You are a food image detection expert. Identify all food items visible in the image."

            # ЁЯза Run GPT calls in parallel
            food_task = asyncio.create_task(
                self._call_gpt_image(system_prompt, prompts["food"], image_base64, as_lines=True)
            )
            nutrition_task = asyncio.create_task(
                self._call_gpt_image(system_prompt, prompts["nutrition"], image_base64, max_tokens=300, as_lines=False)
            )

            def _looks_like_no_food_reply(items):
                if not items:
                    return True

                joined = " ".join(items).lower()
                joined = re.sub(r"[\"',.?!ред]", "", joined)

                # Match by keywords or indicative phrases
                keyword_fragments = [
                    # Gujarati fragments
                    "ркорк╛ркл", "ркЬрк╛ркгрлНркпрлБркВ ркиркерлА", "ркУрк│ркЦрлА рк╢ркХрк╛ркдрлБркВ ркиркерлА", "ркЦрк╛ркжрлНркп", "ркЦрлЛрк░рк╛ркХ ркиркерлА", "ркЦрк╛ркжрлНркп рккркжрк╛рк░рлНрке", "ркиркерлА ркУрк│ркЦрлА", "ркжрлЗркЦрк╛ркдрк╛ ркиркерлА", "ркиркерлА рккркбркдрлЛ", "рк╕рлНрккрк╖рлНркЯ ркиркерлА","ркХрлЛркИ ркЦрлЛрк░рк╛ркХ ркжрлЗркЦрк╛ркдрлЛ ркиркерлА"
                    # English fragments
                    "no food", "sorry", "not detect", "could not see", "unable to identify"
                ]

                return any(kw in joined for kw in keyword_fragments)

            detected_items, gpt_reply_nutrition = await asyncio.gather(food_task, nutrition_task)

            # ЁЯз╝ Clean detected items list
            clean_items = [
                item.strip("- ").strip()
                for item in detected_items
                if item.strip() and not item.strip().startswith("```")
            ]

            print("clean_items", clean_items)

            # тЭМ Reject if no real food detected
            if _looks_like_no_food_reply(clean_items):
                if lang == "gu":
                    error_msg = "ркЫркмрлАркорк╛ркВ ркХрлЛркИ ркЦрлЛрк░рк╛ркХ рк╡рк╕рлНркдрлБ ркУрк│ркЦрлА рк╢ркХрк╛ркпрлА ркиркерлА. ркХрлГрккрк╛ ркХрк░рлАркирлЗ ркЦрлЛрк░рк╛ркХ рк╕ркорк╛рк╡рк┐рк╖рлНркЯ ркирк╡рлА ркЫркмрлА ркЕрккрк▓рлЛркб ркХрк░рлЛ."
                else:
                    error_msg = "No food items detected in the image. Please upload a new image that clearly includes food items."

                return JsonResponse({"error": error_msg}, status=400)

            print("detected_items", detected_items)
            print("gpt_reply_nutrition", gpt_reply_nutrition)

            found_items, missing_items = self._match_menu(menu_list, detected_items)
            nutritions = self._retry_parse(gpt_reply_nutrition, max_retries=3)

            # тЬЕ If nutritions is still empty, recall OpenAI and try again
            if not nutritions:
                print("тЪая╕П Nutrition info was empty. Retrying GPT call...")
                gpt_reply_nutrition = await self._call_gpt_image(
                    system_prompt, prompts["nutrition"], image_base64, max_tokens=300, as_lines=False
                )
                nutritions = self._retry_parse(gpt_reply_nutrition, max_retries=3)

            # тЭМ Still failed after retry
            if not nutritions:
                return JsonResponse({"error": "Nutrition info could not be extracted"}, status=422)

            return JsonResponse({
                "items_food": detected_items,
                "input_menu": menu_list,
                # "found_items": found_items,
                "missing_items": missing_items,
                "nutritions": nutritions
            })

        except Exception as err:
            return JsonResponse({"error": str(err)}, status=500)

    def _get_language_prompts(self, lang: str) -> dict:
        if lang == "gu":
            return {
                "food": (
                    "ркЖ ркЪрк┐ркдрлНрк░ркорк╛ркВ ркжрк░рлНрк╢рк╛рк╡рк╛ркпрлЗрк▓ ркЦрлЛрк░рк╛ркХркирлА ркУрк│ркЦ ркХрк░рлЛ. ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХркирлЛ рк╕рлНрккрк╖рлНркЯ ркЙрк▓рлНрк▓рлЗркЦ ркХрк░рлЛ. "
                    "ркЬрлЛ ркЪрк┐ркдрлНрк░ркорк╛ркВ рк░рк╛ркВркзрлЗрк▓рк╛ ркЪрлЛркЦрк╛ рк╣рлЛркп ркдрлЛ рк╣ркВркорлЗрк╢рк╛ тАЬркнрк╛ркдтАЭ рк╢ркмрлНркж ркЬ рк▓ркЦрлЛ тАФ тАЬркЪрлЛркЦрк╛тАЭ рк╢ркмрлНркж ркирлЛ ркЙрккркпрлЛркЧ рки ркХрк░рлЛ."
                    "ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХркирлА рк╕рк╛ркорлЗ рккрлАрк░рк╕рлЗрк▓рлА ркЕркВркжрк╛ркЬрк┐ркд ркорк╛ркдрлНрк░рк╛ рк▓ркЦрлЛ, ркЧрлНрк░рк╛рко ркЕркерк╡рк╛ ркорк┐рк▓рлА ркПркХркоркорк╛ркВ, ркЕркерк╡рк╛ рк╕ркВркЦрлНркпрк╛ркорк╛ркВ ркЬрлЛ ркдрлЗ рк╡рк╕рлНркдрлБ ркЯрлБркХркбрк╛ркУркорк╛ркВ рк╣рлЛркп (ркЬрлЗрко ркХрлЗ тАЬрли рк░рлЛркЯрк▓рлАтАЭ). рклркХрлНркд ркЪрк┐ркдрлНрк░ркорк╛ркВ ркжрлЗркЦрк╛ркдрлА рк╡рк╕рлНркдрлБркУ ркЬ рк▓ркЦрлЛ, ркЕркВркжрк╛ркЬркерлА ркирк╡рлА рк╡рк╕рлНркдрлБ ркЙркорлЗрк░рк╢рлЛ ркирк╣рлАркВ. рккрк░ркВркдрлБ ркХрлНрк░ркорк╛ркВркХ (рлз, рли, рлй...) ркирлЛ ркЙрккркпрлЛркЧ рки ркХрк░рлЛ." 
                    "рклркХрлНркд ркпрк╛ркжрлА ркЖрккрлЛ. ркорк╛рк╣рк┐ркдрлА ркорк╛ркдрлНрк░ ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ."
                ),
                # "nutrition": (
                #     "ркЖ ркЫркмрлАркорк╛ркВ ркжрлЗркЦрк╛ркдрк╛ ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХ ркорк╛ркЯрлЗ ркдрлЗркирлБркВ ркирк╛рко ркЕркирлЗ ркЕркВркжрк╛ркЬрк┐ркд рккрлЛрк╖ркХ ркорк╛рк╣рк┐ркдрлА ркЖрккрлЛ "
                #     "(ркЬрлЗрко ркХрлЗ ркХрлЗрк▓рк░рлА, рккрлНрк░рлЛркЯрлАрки, ркЪрк░ркмрлА, ркХрк╛рк░рлНркмрлЛрк╣рк╛ркЗркбрлНрк░рлЗркЯрлНрк╕). рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ."
                # ),
                "nutrition": ( "ркдркорк╛рко ркорк╛рк╣рк┐ркдрлА ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ"
                    "ркЖ ркЫркмрлАркорк╛ркВ ркдркоркирлЗ ркХркпрк╛ ркЦрк╛ркжрлНркп рккркжрк╛рк░рлНркерлЛ ркжрлЗркЦрк╛ркп ркЫрлЗ? "
                    "ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХ рк╡рк╕рлНркдрлБ ркорк╛ркЯрлЗ рккрк╣рлЗрк▓рлЗ ркдрлЗркирлБркВ ркирк╛рко рк▓ркЦрлЛ ркЕркирлЗ рккркЫрлА ркдрлЗркирлА ркЕркВркжрк╛ркЬрк┐ркд рккрлЛрк╖ркХ ркорк╛рк╣рк┐ркдрлА ркЖрккрлЛ тАФ "
                    "ркЬрлЗрко ркХрлЗ ркХрлЗрк▓рк░рлА, рккрлНрк░рлЛркЯрлАрки."
                    "ркжрк░рлЗркХ ркЦрлЛрк░рк╛ркХ рк╡рк╕рлНркдрлБркирлЗ ркЕрк▓ркЧ рк░рлАркдрлЗ ркЬркгрк╛рк╡рлЛ. "
                    "Finally, provide a total row for all detected items in the format: "
                    "'ркХрлБрк▓ (рк╕рк░рлНрк╡ ркХрк░рлЗрк▓рлА ркорк╛ркдрлНрк░рк╛ ркорк╛ркЯрлЗ)': {'ркЕркВркжрк╛ркЬрк┐ркд ркХрлЗрк▓рк░рлА': '~XXX ркХрк┐рк▓рлЛркХрлЗрк▓рк░рлА', 'рккрлНрк░рлЛркЯрлАрки': '~YY ркЧрлНрк░рк╛рко'}."
                    "ркдркорк╛рко ркорк╛рк╣рк┐ркдрлА ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА ркнрк╛рк╖рк╛ркорк╛ркВ ркЖрккрлЛ."),
            }
        else:
            return {
                "food": "What food items do you see in this image? Just list them in English.",
                "nutrition": "For each food item visible, give approximate nutrition (calories, protein, fat, carbs) in English."
            }

    async def _call_gpt_image(self, system_prompt, user_text, img_base64, max_tokens=150, as_lines=True):
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": user_text},
                            {"type": "image_url", "image_url": {
                                "url": f"data:image/jpeg;base64,{img_base64}", "detail": "low"
                            }},
                        ],
                    },
                ],
                max_tokens=max_tokens,
                # temperature=1
            )
        )

        reply = response.choices[0].message.content.strip()
        print("reply", reply)
        if as_lines:
            return [
                ln.strip("- ").strip()
                for ln in reply.split("\n")
                if ln.strip() and not ln.strip().startswith("```")
            ]
        return reply

    def _match_menu(self, menu_list, detected_items, threshold=50):
        found, missing = [], []
        for item in menu_list:
            for detected in detected_items:
                if fuzz.partial_ratio(item, detected) >= threshold:
                    found.append(item)
                    break
        missing = [i for i in menu_list if i not in found]
        return found, missing

    def _retry_parse(self, nutrition_text, max_retries=3):
        print("Retrying to parse nutrition info...", nutrition_text)
        for attempt in range(max_retries):
            result = self.parse_nutrition_info(nutrition_text)
            if result:
                # total_nutrition = self.calculate_total_nutrition(result)
                # result["total_nutrition"] = total_nutrition
                return result
        return {}

    def parse_nutrition_info(self, text) -> dict:
        if isinstance(text, list):
            text = "\n".join(text)  # Convert list to string

        nutritions, current = {}, None
        for line in text.split("\n"):
            line = line.strip()
            if not line:
                continue
            match_item = re.match(r"^(?:\d+\.\s*)?\*{2}(.+?)\*{2}", line)
            if match_item:
                current = match_item.group(1).strip()
                nutritions[current] = {}
                continue
            if current:
                num = re.match(r"[-*]?\s*\*{0,2}([\w\u0A80-\u0AFF\s():]+)\*{0,2}\s*[:я╝Ъ]\s*(.+)", line)
                if num:
                    nutritions[current][num.group(1).strip().lower()] = num.group(2).strip()
        return nutritions

    def _convert_image_to_base64(self, image_file):
        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as temp_img:
            for chunk in image_file.chunks():
                temp_img.write(chunk)
            path = temp_img.name

        with open(path, "rb") as f:
            return base64.b64encode(f.read()).decode()

    def calculate_total_nutrition(self, nutritions: dict) -> dict:
        total_calories = 0
        total_protein = 0

        for item, values in nutritions.items():
            kcal_text = values.get("ркХрлЕрк▓рк░рлА", "")
            protein_text = values.get("рккрлНрк░рлЛркЯрлАрки", "")

            # Extract average calorie from range or single number
            kcal_nums = re.findall(r"(\d+)", kcal_text)
            if kcal_nums:
                kcal_nums = list(map(int, kcal_nums))
                avg_kcal = sum(kcal_nums) / len(kcal_nums)
                total_calories += avg_kcal

            # Extract average protein from range or single number
            protein_nums = re.findall(r"(\d+)", protein_text)
            if protein_nums:
                protein_nums = list(map(int, protein_nums))
                avg_protein = sum(protein_nums) / len(protein_nums)
                total_protein += avg_protein

        return {
            "total_kcal": round(total_calories, 2),
            "total_protein_g": round(total_protein, 2)
        }


